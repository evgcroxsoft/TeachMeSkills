Для работы нам нужно:

1. Создасть папку проекта mkdir Project_name
2. Создать создать виртуальное окружение python3 -m venv venv и активировать его source venv/bin/activate
3. Установить фреймфорк и необходимые вспомагательные библиотеки например: FastAPI, uvicorn
4. Устновить Базу Данных Для примера POSTGRESQL на машину или с помощью докера.
5. Создать файл .env и закинуть в environment с помощью source .env 
    - export POSTGRES_URL=localhost:5432
    - export POSTGRES_USER=zhenya
    - export POSTGRES_PW='`b{5:P3kUv5LdJF.'
    - export POSTGRES_DB=fastapi_db
6. Нужно создать дерево в проекте, папки и модули:
    models
        __init__.py
        models.py
    routes 
        __init__.py
    database
        __init__.py
        db.py
    schema
        __init__.py
    services
        __init__.py
    config.py
    main.py
    requirements.txt
    dependecies.py

7. Старт проекта в файле main.py 

#импортируем FastAPI и uvicorn
from fastapi import FastAPI
import uvicorn

#создаем объeкт app
app = FastAPI()

#создаем прописываем автоматический запуск сервера uvicorn при запуске приложения main.py
if __name__ == "__main__":
    uvicorn.run('main:app', port=8000, host='0.0.0.0', reload=True)


8. Пайдентик мы используем для валидации данных при чтении и записи их, мы используем 
Квери параметры мы используем для пагинации, для сортировок...
limit: int | None = None - читается как парметр limit тип данных int или None, по дефолту None
если мы хотим указать обязательные квери параметры, тогда только пишем например: limit: int, без указания равно 10 или None
В практике используют requestItem и respopnseItem. Это нужно для того чтоб принимать данные можно было например с паролем, а отдавать уже не указывая пароль
Пайдентик дает нам возможность также сhазу работать с методами, item.sum + item.tax  return item_dict
Мы можем одновременно передать несколько объектов и сразу одновременно с ними работать, пандентик такое позволяет делать, пример: item: Item, user: User
При использовании Field мы можем добавить больше описаний что мы хотим видеть, например: price: float = Field(gt=0, description='Blabla')
https://docs.python.org/3/library/operator.html - таблицы значений сокращений gt
Можно делать вложенности в запросе, например, мы создаем class Image с полями урл и нейм, и после закидываем в другую: image: Image | None = None
Чаще всего так также передают Теги.
Можно также передавать и другие значения 
Валидация делается на основе headerа. 
response_model=UserOut - нужно как раз для того чтоб принимать к примеру значения с паролем, а отдавать без.
__init__.py нужны для того чтоб подхватывались все модули в папке в общий проект и строились импорты.
при создании status_code=200 - можем указывать сами что будет какой статус или status_code=status.created импортим статусы и поехали
201 статус created
в FastAPI можно принимать или JSON или FORM для этого нужно импортировать FORM (form-data вкладка в postman чаще всего через него отправляется файл)
Можно писать свои Exceptions 
Также можно использовать summury в строке с использованием языка markdown
метод get.put все поля обящзательные данных
метод get.patch одно поле для обновления данных
dependecies используются часто во многих местах, они пишутся как функия, в которой описыватся параметры, а там где нам нужно мы просто вызываем эту функцию
например депендинси для аутентификации, мы в одном модуле прописываем сначала функцию для аутентификации например через JWT потом, эту всегда прописываем
Depends(get_current_user)
JWT работает скорее всего так, мы по ключу получаем пользователя, сравниваем его токен, и потом, отдаем его айдишник.
Можно и нужно сразу поместить при создании app = FastAPI(dependecies=[Depends(veryfy_token), Depends(verify_key)])
FastAPI всегда использует вначале async и нам нужно использовать await, если так не сделать то выполнение функции просто пойдет дальше и выполниться когда-то,
а не сейчас. Если нам не нужно ждать рехультат, то await мы не пишем перед функцией.

Гугл использует для авторизации OpenID connect(под капотом которого OAuth2)
В свою очередь OAuth2 не шифрует трафик, за это отвечает HTTPS for free, using Traefik and Let's Encrypt.

Swagger в прошлом, а сейчас это OpenAPI, FastAPI использует OpenAPI под капотом. В свою очередь OpenAPI передает секьюрно параметры куки, квери и хедер

проверка безопасности и зависимости пишеться только один раз, и потом просто вызываются в каждом отдельном endpoint


Модели мы создаем в одном месте Пайдентик
аутентификации мы создаем в другом месте и прописываем функцию которая принимает и проверяет токен и отдает пользователя по токену
а уже в в рутах мы прописываем зависимости от get_current_user.


Идентификация — процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе.
Аутентификация — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
Авторизация — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.    

access token 
refresh token

Принцип работы должен быть такой:
Пользователь первый раз зашел на сайт и регистрируется, при регистрации он автоматические получаем пару токенов,
один для доступов, второй для рефреш. У каждого токена есть свое время действительности. После того как токен access перестал работать, 
пользователь автоматические должен получить другой access токен при этом зайдейтсвуется refresh token.
/api/token/ - по этому пути доступ и валидация
/api/token/refresh  - по этому пути будет постоянно обновление токена,



API нужен для того, чтоб получать и обрабатывать информацию путем запросов и передачи данных даже без дизайна, например с помощью постман.


Для работы роутеров, необходимо подгружать их импортами в main.py
Также все роутеры, можно сделать минимальными и только вызывать основные функции, таким образом код будет более читаебельным.
Все функции можно вынести в сервисы и оттуда просто их подтягивать.